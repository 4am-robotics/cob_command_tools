// ROS message includes
#include "ros/ros.h"
#include <sensor_msgs/JoyFeedback.h>
#include <geometry_msgs/Twist.h>
#include <brics_actuator/CartesianTwist.h>
#include <brics_actuator/CartesianTwist.h>
#include <brics_actuator/JointVelocities.h>
#include <brics_actuator/JointVelocities.h>
#include <geometry_msgs/Twist.h>
#include <brics_actuator/JointVelocities.h>
#include <geometry_msgs/Twist.h>
#include <sensor_msgs/Joy.h>

/* protected region user include files on begin */
int mode=0;
/* protected region user include files end */

class cob_teleop_cob4_config
{
public:
    int button_deadman;
    double base_max_linear;
    double base_max_angular;
    double torso_max_angular;
    double head_max_angular;
    double sensor_ring_max_angular;
    double arm_joint_velocity_max;
    double arm_cartesian_max_linear;
    double arm_cartesian_max_angular;
    double gripper_max_velocity;
    int base_x;
    int base_y;
    int base_yaw;
    int arm_x;
    int arm_y;
    int arm_yaw;
    int arm_pitch_up;
    int arm_pitch_down;
    int arm_roll_right_and_ellbow;
    int arm_roll_left_and_ellbow;
    int arm_z_up;
    int arm_z_down;
    int gripper_open;
    int gripper_close;
    int arm_joint_up;
    int arm_joint_down;
    int arm_joint_left;
    int arm_joint_right;
    int arm_joint_12;
    int arm_joint_34;
    int arm_joint_56;
    int arm_joint_7_gripper;
    int axis_runfactor;
    int button_safety_override;
    int button_init_recover;
    int button_mode_switch;
};

class cob_teleop_cob4_data
{
// autogenerated: don't touch this class
public:
    //input data
    sensor_msgs::Joy in_joy;
    //output data
    sensor_msgs::JoyFeedback out_joy_feedback;
    bool out_joy_feedback_active;
    geometry_msgs::Twist out_base_controller_command;
    bool out_base_controller_command_active;
    brics_actuator::CartesianTwist out_arm_cart_left;
    bool out_arm_cart_left_active;
    brics_actuator::CartesianTwist out_arm_cart_right;
    bool out_arm_cart_right_active;
    brics_actuator::JointVelocities out_arm_joint_right;
    bool out_arm_joint_right_active;
    brics_actuator::JointVelocities out_arm_joint_left;
    bool out_arm_joint_left_active;
    geometry_msgs::Twist out_head_controller_command;
    bool out_head_controller_command_active;
    brics_actuator::JointVelocities out_sensorring_controller_command;
    bool out_sensorring_controller_command_active;
    geometry_msgs::Twist out_torso_controller_command;
    bool out_torso_controller_command_active;
};

class cob_teleop_cob4_impl
{
    /* protected region user member variables on begin */
    /* protected region user member variables end */

public:
    cob_teleop_cob4_impl() 
    {
        /* protected region user constructor on begin */
        /* protected region user constructor end */
    }

    void configure(cob_teleop_cob4_config config) 
    {
        /* protected region user configure on begin */
        /* protected region user configure end */
    }

    void update(cob_teleop_cob4_data &data, cob_teleop_cob4_config config)
    {
        /* protected region user update on begin */
	if (data.in_joy.buttons.size()!=17)//wait for full joypad
	{	
		ROS_WARN("joypad inactive! waiting for vector of buttons");
		return;
	}
	
	if (data.in_joy.buttons.at(config.button_mode_switch))//switch mode. gets executed multiple times
	{
		++mode;
		if (mode >= 4)
		{
			mode = 0;
		}
		ROS_WARN("Mode switched to: %d",mode);
		ros::Duration(0.5).sleep();//wait (bad place)
		return;
	}


	if (data.in_joy.buttons.at(config.button_deadman))
	{
		switch (mode)
		{
		case 0: //Base
		data.out_base_controller_command.linear.x=data.in_joy.axes[config.base_x]*config.base_max_linear;
		data.out_base_controller_command.linear.y=data.in_joy.axes[config.base_y]*config.base_max_linear;
		data.out_base_controller_command.angular.z=data.in_joy.axes[config.base_yaw]*config.base_max_angular;
		data.out_base_controller_command_active=1;
		break;
		
		case 1: //arm cartesian left
		data.out_arm_cart_left.translation.x=(data.in_joy.axes[config.arm_x])*config.arm_cartesian_max_linear;
		data.out_arm_cart_left.translation.y=(data.in_joy.axes[config.arm_y])*config.arm_cartesian_max_linear;
		data.out_arm_cart_left.rotation.z=(data.in_joy.axes[config.arm_yaw])*config.arm_cartesian_max_angular;
		data.out_arm_cart_left.translation.z=(data.in_joy.buttons[config.arm_z_up]*run_factor(data)-data.in_joy.buttons[config.arm_z_down])*run_factor(data)*config.arm_cartesian_max_linear;
		data.out_arm_cart_left.rotation.x=(data.in_joy.buttons[config.arm_roll_left_and_ellbow]*run_factor(data)-data.in_joy.buttons[config.arm_roll_right_and_ellbow])*run_factor(data)*config.arm_cartesian_max_angular;
		data.out_arm_cart_left.rotation.y=(data.in_joy.buttons[config.arm_pitch_up]*run_factor(data)-data.in_joy.buttons[config.arm_pitch_down])*run_factor(data)*config.arm_cartesian_max_angular;
		break;
		
		case 2: //arm_cartesian right
		data.out_arm_cart_right.translation.x=(data.in_joy.axes[config.arm_x])*config.arm_cartesian_max_linear;
		data.out_arm_cart_right.translation.y=(data.in_joy.axes[config.arm_y])*config.arm_cartesian_max_linear;
		data.out_arm_cart_right.rotation.z=(data.in_joy.axes[config.arm_yaw])*config.arm_cartesian_max_angular;
		data.out_arm_cart_right.translation.z=(data.in_joy.buttons[config.arm_z_up]*run_factor(data)-data.in_joy.buttons[config.arm_z_down])*run_factor(data)*config.arm_cartesian_max_linear;
		data.out_arm_cart_right.rotation.x=(data.in_joy.buttons[config.arm_roll_left_and_ellbow]*run_factor(data)-data.in_joy.buttons[config.arm_roll_right_and_ellbow])*run_factor(data)*config.arm_cartesian_max_angular;
		data.out_arm_cart_right.rotation.y=(data.in_joy.buttons[config.arm_pitch_up]*run_factor(data)-data.in_joy.buttons[config.arm_pitch_down])*run_factor(data)*config.arm_cartesian_max_angular;
		break;
		
		case 3: //sensorring head torso 
		data.out_sensorring_controller_command.velocities[0].timeStamp=ros::Time::now();
		data.out_sensorring_controller_command.velocities[0].joint_uri='sensorring_joint';
		data.out_sensorring_controller_command.velocities[0].unit='rad';
		data.out_sensorring_controller_command.velocities[0].value=27;
		data.out_sensorring_controller_command_active=1;
		
		}
		
	}
	else 
	{
		data.out_base_controller_command_active=0;
		data.out_sensorring_controller_command_active=0;
	}
        /* protected region user update end */
    }


    /* protected region user additional functions on begin */
    float run_factor(cob_teleop_cob4_data &data)
    {
	float result;
	result = -data.in_joy.axes.at(9);//negative values
	return result;
    }
    /* protected region user additional functions end */
};
