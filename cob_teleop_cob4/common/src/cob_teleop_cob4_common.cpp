// ROS message includes
#include "ros/ros.h"
#include <sensor_msgs/JoyFeedback.h>
#include <geometry_msgs/Twist.h>
#include <brics_actuator/CartesianTwist.h>
#include <brics_actuator/CartesianTwist.h>
#include <trajectory_msgs/JointTrajectory.h>
#include <trajectory_msgs/JointTrajectory.h>
#include <trajectory_msgs/JointTrajectory.h>
#include <brics_actuator/JointVelocities.h>
#include <geometry_msgs/Twist.h>
#include <sensor_msgs/Joy.h>

/* protected region user include files on begin */
int mode=0;
/* protected region user include files end */

class cob_teleop_cob4_config
{
public:
    int button_deadman;
    double base_max_linear;
    double base_max_angular;
    double torso_max_angular;
    double head_max_angular;
    double sensor_ring_max_angular;
    double arm_joint_velocity_max;
    double arm_cartesian_max_linear;
    double arm_cartesian_max_angular;
    double gripper_max_velocity;
    int base_x;
    int base_y;
    int base_yaw;
    int arm_x;
    int arm_y;
    int arm_yaw;
    int arm_pitch_up;
    int arm_pitch_down;
    int arm_roll_right_and_ellbow;
    int arm_roll_left_and_ellbow;
    int arm_z_up;
    int arm_z_down;
    int gripper_open;
    int gripper_close;
    int arm_joint_up;
    int arm_joint_down;
    int arm_joint_left;
    int arm_joint_right;
    int arm_joint_12;
    int arm_joint_34;
    int arm_joint_56;
    int arm_joint_7_gripper;
    int axis_runfactor;
    int button_safety_override;
    int button_init_recover;
    int button_mode_switch;
    int torso_roll;
    int torso_pitch;
    int torso_yaw_left;
    int torso_yaw_right;
    int sensorring_yaw_left;
    int sensorring_yaw_right;
};

class cob_teleop_cob4_data
{
// autogenerated: don't touch this class
public:
    //input data
    sensor_msgs::Joy in_joy;
    //output data
    sensor_msgs::JoyFeedback out_joy_feedback;
    bool out_joy_feedback_active;
    geometry_msgs::Twist out_base_controller_command;
    bool out_base_controller_command_active;
    brics_actuator::CartesianTwist out_arm_cart_left;
    bool out_arm_cart_left_active;
    brics_actuator::CartesianTwist out_arm_cart_right;
    bool out_arm_cart_right_active;
    trajectory_msgs::JointTrajectory out_arm_joint_right;
    bool out_arm_joint_right_active;
    trajectory_msgs::JointTrajectory out_arm_joint_left;
    bool out_arm_joint_left_active;
    trajectory_msgs::JointTrajectory out_head_controller_command;
    bool out_head_controller_command_active;
    brics_actuator::JointVelocities out_sensorring_controller_command;
    bool out_sensorring_controller_command_active;
    geometry_msgs::Twist out_torso_controller_command;
    bool out_torso_controller_command_active;
};

class cob_teleop_cob4_impl
{
    /* protected region user member variables on begin */
    float run;
    float updown;
    float leftright;    
    brics_actuator::JointValue sring;
    trajectory_msgs::JointTrajectory head_velocity;
    geometry_msgs::Twist base;
    geometry_msgs::Twist torso;
    sensor_msgs::Joy joy;
    trajectory_msgs::JointTrajectory left;
    trajectory_msgs::JointTrajectory right;
    /* protected region user member variables end */

public:
    cob_teleop_cob4_impl() 
    {
        /* protected region user constructor on begin */
        /* protected region user constructor end */
    }

    void configure(cob_teleop_cob4_config config) 
    {
        /* protected region user configure on begin */
      left.joint_names.push_back("arm_left_1_joint");
      left.joint_names.push_back("arm_left_2_joint");
      left.joint_names.push_back("arm_left_3_joint");
      left.joint_names.push_back("arm_left_4_joint");
      left.joint_names.push_back("arm_left_5_joint");
      left.joint_names.push_back("arm_left_6_joint");
      left.joint_names.push_back("arm_left_7_joint");
      left.points.resize(1);
      left.points.at(0).velocities.resize(7);
      right.joint_names.push_back("arm_right_1_joint");
      right.joint_names.push_back("arm_right_2_joint");
      right.joint_names.push_back("arm_right_3_joint");
      right.joint_names.push_back("arm_right_4_joint");
      right.joint_names.push_back("arm_right_5_joint");
      right.joint_names.push_back("arm_right_6_joint");
      right.joint_names.push_back("arm_right_7_joint");
      right.points.resize(1);
      right.points.at(0).velocities.resize(7);
      
        /* protected region user configure end */
    }

    void update(cob_teleop_cob4_data &data, cob_teleop_cob4_config config)
    {
        /* protected region user update on begin */
    if (data.in_joy.buttons.size()!=17)//wait for complete joypad!
    {  
      ROS_WARN("joypad inactive! waiting for vector of buttons. Move the Controller");
      return;
    }
    
    joy=data.in_joy;//bit smaller
    run=1-joy.axes[config.axis_runfactor];
    updown=(joy.buttons[config.arm_joint_up]-joy.buttons[config.arm_joint_down]);
    leftright=(joy.buttons[config.arm_joint_left]-joy.buttons[config.arm_joint_right]);
  
    if (joy.buttons.at(config.button_mode_switch) && not joy.buttons[config.button_deadman])//switch mode. gets executed multiple times
    {
      ++mode;
      if (mode >= 6)
      {
        mode = 0;
      }
      ROS_WARN("Mode switched to: %d",mode);
      ros::Duration(0.5).sleep();//wait (bad place)
      return;
    }
    
    if (joy.buttons[config.button_deadman])
    {
  
      switch (mode)
      {
      case 0: //Base
      base.linear.x=joy.axes[config.base_x]*config.base_max_linear*run;
      base.linear.y=joy.axes[config.base_y]*config.base_max_linear*run;
      base.angular.z=joy.axes[config.base_yaw]*config.base_max_angular*run;
      data.out_base_controller_command=base;
      data.out_base_controller_command_active=1;
      break;
      
      case 1: //arm cartesian left
      data.out_arm_cart_left.translation.x=(joy.axes[config.arm_x])*config.arm_cartesian_max_linear*run;
      data.out_arm_cart_left.translation.y=(joy.axes[config.arm_y])*config.arm_cartesian_max_linear*run;
      data.out_arm_cart_left.rotation.z=(joy.axes[config.arm_yaw])*config.arm_cartesian_max_angular*run;
      data.out_arm_cart_left.translation.z=(joy.buttons[config.arm_z_up]-joy.buttons[config.arm_z_down])*run*config.arm_cartesian_max_linear;
      data.out_arm_cart_left.rotation.x=(joy.buttons[config.arm_roll_left_and_ellbow]-joy.buttons[config.arm_roll_right_and_ellbow])*run*config.arm_cartesian_max_angular;
      data.out_arm_cart_left.rotation.y=(joy.buttons[config.arm_pitch_up]-joy.buttons[config.arm_pitch_down])*run*config.arm_cartesian_max_angular;
      break; //maybe these blocks should be smaller
      
      case 2: //arm_cartesian right
      data.out_arm_cart_right.translation.x=(joy.axes[config.arm_x])*config.arm_cartesian_max_linear*run;
      data.out_arm_cart_right.translation.y=(joy.axes[config.arm_y])*config.arm_cartesian_max_linear*run;
      data.out_arm_cart_right.rotation.z=(joy.axes[config.arm_yaw])*config.arm_cartesian_max_angular*run;
      data.out_arm_cart_right.translation.z=(joy.buttons[config.arm_z_up]-joy.buttons[config.arm_z_down])*run*config.arm_cartesian_max_linear;
      data.out_arm_cart_right.rotation.x=(joy.buttons[config.arm_roll_left_and_ellbow]-joy.buttons[config.arm_roll_right_and_ellbow])*run*config.arm_cartesian_max_angular;
      data.out_arm_cart_right.rotation.y=(joy.buttons[config.arm_pitch_up]-joy.buttons[config.arm_pitch_down])*run*config.arm_cartesian_max_angular;
      break;
      
      case 3: //arm_joints_left
      left.points[0].velocities[0]=updown*joy.buttons[config.arm_joint_12]*run*config.arm_joint_velocity_max;
      left.points[0].velocities[1]=leftright*joy.buttons[config.arm_joint_12]*run*config.arm_joint_velocity_max;
      left.points[0].velocities[2]=updown*joy.buttons[config.arm_joint_34]*run*config.arm_joint_velocity_max;
      left.points[0].velocities[3]=leftright*joy.buttons[config.arm_joint_34]*run*config.arm_joint_velocity_max;
      left.points[0].velocities[4]=updown*joy.buttons[config.arm_joint_56]*run*config.arm_joint_velocity_max;
      left.points[0].velocities[5]=leftright*joy.buttons[config.arm_joint_56]*run*config.arm_joint_velocity_max;
      left.points[0].velocities[6]=updown*joy.buttons[config.arm_joint_7_gripper]*run*config.arm_joint_velocity_max;
      left.points[0].time_from_start=ros::Duration(0.1);
      //left.joint_gripper=leftright*joy.buttons[config.arm_joint_7_gripper]*run*config.arm_joint_velocity_max;
      data.out_arm_joint_left=left;
      data.out_arm_joint_left_active=1;
      break;
      
      case 4: //arm_joints_right    
      right.points[0].velocities[0]=updown*joy.buttons[config.arm_joint_12]*run*config.arm_joint_velocity_max;
      right.points[0].velocities[1]=leftright*joy.buttons[config.arm_joint_12]*run*config.arm_joint_velocity_max;
      right.points[0].velocities[2]=updown*joy.buttons[config.arm_joint_34]*run*config.arm_joint_velocity_max;
      right.points[0].velocities[3]=leftright*joy.buttons[config.arm_joint_34]*run*config.arm_joint_velocity_max;
      right.points[0].velocities[4]=updown*joy.buttons[config.arm_joint_56]*run*config.arm_joint_velocity_max;
      right.points[0].velocities[5]=leftright*joy.buttons[config.arm_joint_56]*run*config.arm_joint_velocity_max;
      right.points[0].velocities[6]=updown*joy.buttons[config.arm_joint_7_gripper]*run*config.arm_joint_velocity_max;
      right.points[0].time_from_start=ros::Duration(0.1);;
      //right.joint_gripper=rightright*joy.buttons[config.arm_joint_7_gripper]*run*config.arm_joint_velocity_max;
      data.out_arm_joint_right=right;
      data.out_arm_joint_right_active=1;
      break;
      /*
      case 5 : //automoves script
      //Todo
      break;
      */
      
      case 5: //6 sensorring head torso 
      //sensorring
      sring.timeStamp=ros::Time::now();
      sring.joint_uri="sensorring_joint";
      sring.unit="rad";
      sring.value=(joy.buttons[config.sensorring_yaw_left]-joy.buttons[config.sensorring_yaw_right])*config.sensor_ring_max_angular*run;
      if (data.out_sensorring_controller_command.velocities.size()==0) //only required once, need better place
      {
          data.out_sensorring_controller_command.velocities.push_back(sring);//only thing I got working for init.
          ROS_WARN("Setting size");
      }
      data.out_sensorring_controller_command.velocities[0]=sring;//now it's possible to overwrite
      data.out_sensorring_controller_command_active=1;
      //head 
      //head_velocity.joint_names.at(0)="head_1_joint";
      //head_velocity.joint_names.at(1)="head_2_joint";
      //head_velocity.joint_names.at(2)="head_3_joint";
      //head_velocity.points.at(0).velocities.at(0)=data.in_joy.axes[1]; //something like one of these three?
      //head_velocity.points.velocities.at(1)=data.in_joy.axes[2];
      //head_velocity.points.at(2).velocities=data.in_joy.axes[3];
      //head_velocity.points.time_from_start=ros::Time::now; //not even this works. Probably also push_back or similar required
      //torso
      torso.angular.x=joy.axes[config.torso_roll]*config.torso_max_angular*run;
      torso.angular.y=joy.axes[config.torso_pitch]*config.torso_max_angular*run;
      torso.angular.z=(joy.buttons[config.torso_yaw_left]-joy.buttons[config.torso_yaw_right])*config.torso_max_angular*run;
      data.out_torso_controller_command=torso;
      data.out_torso_controller_command_active=1;
      
      break;
      }
    
    }
  else 
  {
    data.out_base_controller_command_active=0;
    data.out_sensorring_controller_command_active=0;
    data.out_torso_controller_command_active=0;
    data.out_arm_joint_left_active=0;
    data.out_arm_joint_right_active=0;
  }
        /* protected region user update end */
    }


    /* protected region user additional functions on begin */
    //Todo: overload parameter and function, so 2Inputs for pair of buttons, one for axis
  float run_factor(cob_teleop_cob4_data &data) //dont need a function for this, will be removed
  {
  float result;
  result = 1-data.in_joy.axes.at(9);//value between 1 and 2
  return result;
  }
    /* protected region user additional functions end */
};
