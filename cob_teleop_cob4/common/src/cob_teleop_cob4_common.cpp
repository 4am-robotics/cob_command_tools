// ROS message includes
#include "ros/ros.h"
#include <sensor_msgs/JoyFeedback.h>
#include <geometry_msgs/Twist.h>
#include <brics_actuator/CartesianTwist.h>
#include <brics_actuator/CartesianTwist.h>
#include <brics_actuator/JointVelocities.h>
#include <brics_actuator/JointVelocities.h>
#include <trajectory_msgs/JointTrajectory.h>
#include <brics_actuator/JointVelocities.h>
#include <geometry_msgs/Twist.h>
#include <sensor_msgs/Joy.h>

/* protected region user include files on begin */
int mode=0;
/* protected region user include files end */

class cob_teleop_cob4_config
{
public:
    int button_deadman;
    double base_max_linear;
    double base_max_angular;
    double torso_max_angular;
    double head_max_angular;
    double sensor_ring_max_angular;
    double arm_joint_velocity_max;
    double arm_cartesian_max_linear;
    double arm_cartesian_max_angular;
    double gripper_max_velocity;
    int base_x;
    int base_y;
    int base_yaw;
    int arm_x;
    int arm_y;
    int arm_yaw;
    int arm_pitch_up;
    int arm_pitch_down;
    int arm_roll_right_and_ellbow;
    int arm_roll_left_and_ellbow;
    int arm_z_up;
    int arm_z_down;
    int gripper_open;
    int gripper_close;
    int arm_joint_up;
    int arm_joint_down;
    int arm_joint_left;
    int arm_joint_right;
    int arm_joint_12;
    int arm_joint_34;
    int arm_joint_56;
    int arm_joint_7_gripper;
    int axis_runfactor;
    int button_safety_override;
    int button_init_recover;
    int button_mode_switch;
};

class cob_teleop_cob4_data
{
// autogenerated: don't touch this class
public:
    //input data
    sensor_msgs::Joy in_joy;
    //output data
    sensor_msgs::JoyFeedback out_joy_feedback;
    bool out_joy_feedback_active;
    geometry_msgs::Twist out_base_controller_command;
    bool out_base_controller_command_active;
    brics_actuator::CartesianTwist out_arm_cart_left;
    bool out_arm_cart_left_active;
    brics_actuator::CartesianTwist out_arm_cart_right;
    bool out_arm_cart_right_active;
    brics_actuator::JointVelocities out_arm_joint_right;
    bool out_arm_joint_right_active;
    brics_actuator::JointVelocities out_arm_joint_left;
    bool out_arm_joint_left_active;
    trajectory_msgs::JointTrajectory out_head_controller_command;
    bool out_head_controller_command_active;
    brics_actuator::JointVelocities out_sensorring_controller_command;
    bool out_sensorring_controller_command_active;
    geometry_msgs::Twist out_torso_controller_command;
    bool out_torso_controller_command_active;
};

class cob_teleop_cob4_impl
{
    /* protected region user member variables on begin */
    float run;
    brics_actuator::JointValue sring;
    trajectory_msgs::JointTrajectory head_velocity;
    geometry_msgs::Twist base;
    sensor_msgs::Joy joy;
    /* protected region user member variables end */

public:
    cob_teleop_cob4_impl() 
    {
        /* protected region user constructor on begin */
        /* protected region user constructor end */
    }

    void configure(cob_teleop_cob4_config config) 
    {
        /* protected region user configure on begin */
        /* protected region user configure end */
    }

    void update(cob_teleop_cob4_data &data, cob_teleop_cob4_config config)
    {
        /* protected region user update on begin */
    if (data.in_joy.buttons.size()!=17)//wait for full joypad
  {  
    ROS_WARN("joypad inactive! waiting for vector of buttons. Move the Controller");
    return;
  }
  
  if (data.in_joy.buttons.at(config.button_mode_switch))//switch mode. gets executed multiple times
  {
    ++mode;
    if (mode >= 4)
    {
      mode = 0;
    }
    ROS_WARN("Mode switched to: %d",mode);
    ros::Duration(0.5).sleep();//wait (bad place)
    //deactivate publishing during mode switch (or allow mode selection only if deadman is not pressed?)
    data.out_base_controller_command_active=0;
    data.out_sensorring_controller_command_active=0;
    return;
  }


  if (data.in_joy.buttons.at(config.button_deadman))
  {
    joy=data.in_joy;//bit smaller
    run=1-joy.axes[config.axis_runfactor];
    switch (mode)
    {
    case 0: //Base
    base.linear.x=joy.axes[config.base_x]*config.base_max_linear*run;
    base.linear.y=joy.axes[config.base_y]*config.base_max_linear*run;
    base.angular.z=joy.axes[config.base_yaw]*config.base_max_angular*run;
    data.out_base_controller_command=base;
    data.out_base_controller_command_active=1;
    break;
    
    case 1: //arm cartesian left
    data.out_arm_cart_left.translation.x=(joy.axes[config.arm_x])*config.arm_cartesian_max_linear*run;
    data.out_arm_cart_left.translation.y=(joy.axes[config.arm_y])*config.arm_cartesian_max_linear*run;
    data.out_arm_cart_left.rotation.z=(joy.axes[config.arm_yaw])*config.arm_cartesian_max_angular*run;
    data.out_arm_cart_left.translation.z=(joy.buttons[config.arm_z_up]-joy.buttons[config.arm_z_down])*run*config.arm_cartesian_max_linear;
    data.out_arm_cart_left.rotation.x=(joy.buttons[config.arm_roll_left_and_ellbow]-joy.buttons[config.arm_roll_right_and_ellbow])*run*config.arm_cartesian_max_angular;
    data.out_arm_cart_left.rotation.y=(joy.buttons[config.arm_pitch_up]-joy.buttons[config.arm_pitch_down])*run*config.arm_cartesian_max_angular;
    break; //maybe these blocks should be smaller
    
    case 2: //arm_cartesian right
    data.out_arm_cart_right.translation.x=(joy.axes[config.arm_x])*config.arm_cartesian_max_linear*run;
    data.out_arm_cart_right.translation.y=(joy.axes[config.arm_y])*config.arm_cartesian_max_linear*run;
    data.out_arm_cart_right.rotation.z=(joy.axes[config.arm_yaw])*config.arm_cartesian_max_angular*run;
    data.out_arm_cart_right.translation.z=(joy.buttons[config.arm_z_up]-joy.buttons[config.arm_z_down])*run*config.arm_cartesian_max_linear;
    data.out_arm_cart_right.rotation.x=(joy.buttons[config.arm_roll_left_and_ellbow]-joy.buttons[config.arm_roll_right_and_ellbow])*run*config.arm_cartesian_max_angular;
    data.out_arm_cart_right.rotation.y=(joy.buttons[config.arm_pitch_up]-joy.buttons[config.arm_pitch_down])*run*config.arm_cartesian_max_angular;
    break;
    
    case 3: //sensorring head torso 
    //sensorring
    sring.timeStamp=ros::Time::now();
    sring.joint_uri="sensorring_joint";
    sring.unit="rad";
    sring.value=joy.axes[0];
    if (data.out_sensorring_controller_command.velocities.size()==0) //only required once, need better place
    {
        data.out_sensorring_controller_command.velocities.push_back(sring);//only thing I got working for init.
        ROS_WARN("Setting size");
    }
    data.out_sensorring_controller_command.velocities[0]=sring;//now it's possible to overwrite
    data.out_sensorring_controller_command_active=1;
    //head 
    //head_velocity.joint_names.at(0)="head_1_joint";
    //head_velocity.joint_names.at(1)="head_2_joint";
    //head_velocity.joint_names.at(2)="head_3_joint";
    //head_velocity.points.at(0).velocities.at(0)=data.in_joy.axes[1]; //something like one of these three?
    //head_velocity.points.velocities.at(1)=data.in_joy.axes[2];
    //head_velocity.points.at(2).velocities=data.in_joy.axes[3];
    //head_velocity.points.time_from_start=ros::Time::now; //not even this works. Probably also push_back or similar required
    //torso
    break;
    
    
    }
    
  }
  else 
  {
    data.out_base_controller_command_active=0;
    data.out_sensorring_controller_command_active=0;
  }
        /* protected region user update end */
    }


    /* protected region user additional functions on begin */
    //Todo: overload parameter and function, so 2Inputs for pair of buttons, one for axis
  float run_factor(cob_teleop_cob4_data &data) //dont need a function for this, will be removed
  {
  float result;
  result = 1-data.in_joy.axes.at(9);//value between 1 and 2
  return result;
  }
    /* protected region user additional functions end */
};
